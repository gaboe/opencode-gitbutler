# Command: Analyze Plugin Loop

> Runtime DX analysis for `opencode-gitbutler` plugin across real projects.
> You are the product owner. Observe, diagnose, report. Never patch autonomously.

---

## Purpose

Run a bounded analysis loop that:
1. Evaluates plugin behavior against the **Feature Parity Baseline** (below)
2. Diagnoses end-to-end DX flows: branch creation → file assignment → commit → reword → cleanup
3. Identifies broken, degraded, or unreliable behaviors from real runtime data
4. Produces a structured DX report with actionable findings
5. Proposes improvements — but **consults the operator** before any code changes

**This is a read-only diagnostic tool.** No file edits, no patches, no git mutations.

### Source of Truth

The full feature comparison table, architecture decisions, known issues, and parity assessment live in:

**`docs/gitbutler-integration.md`**

Read this document before starting analysis. The Feature Parity Baseline below is derived from it.

---

## Mindset: Product Owner

You are not debugging source code. You are evaluating a product:

- **Does the branch get created when the user starts working?**
- **Does the file land in the right branch, or does it float as unassigned?**
- **Does the commit message reflect what the user actually asked for?**
- **Does the branch name make sense, or is it still `ge-branch-42`?**
- **Do subagent sessions leak empty branches?**
- **Does the agent know what happened (context injection)?**

Every finding should answer: *"What did the user experience, and was it correct?"*

---

## Feature Parity Baseline

This is your scorecard. For each feature, verify whether it works correctly in the observed data.

### Lifecycle Hooks

| # | Feature | Expected Behavior | How to Verify |
|---|---------|-------------------|---------------|
| 1 | Post-edit hook | Every file edit triggers `but cursor after-edit` | debug.log: `cursor-ok` with `subcommand: "after-edit"` after each edit |
| 2 | Stop/idle hook | Session idle triggers `but cursor stop` → commit created | debug.log: `session-stop` → `cursor-ok` with `subcommand: "stop"` |
| 3 | Pre-edit lock | Concurrent edits are serialized via file lock | debug.log: `lock-acquired` before every `after-edit`, `lock-released` after |

### Branch & File Management

| # | Feature | Expected Behavior | How to Verify |
|---|---------|-------------------|---------------|
| 4 | Branch creation | New session → new branch via `conversation_id` | debug.log: `session-map-created` or `cursor-ok` with new session |
| 5 | File-to-branch assignment | Edited file assigned to correct branch | `but status --json -f`: file appears in branch's `assignedChanges` or `changes[]` |
| 6 | Auto-assign existing branch | Re-edit of committed file → `but rub` to correct branch | debug.log: `rub-ok` with file and branch IDs |
| 7 | No phantom branches | Subagent read-only sessions don't create empty branches | debug.log: NO `cursor-ok` for sessions without prior `after-edit` |
| 8 | Empty branch cleanup | Leftover `ge-branch-*` with 0 commits get unapplied | debug.log: `cleanup-ok` entries |

### Commit Quality

| # | Feature | Expected Behavior | How to Verify |
|---|---------|-------------------|---------------|
| 9 | Auto-commit on stop | Idle → commit created on correct branch | debug.log: `session-stop` → `cursor-ok` (stop) → `post-stop-start` |
| 10 | LLM commit message | Commit message generated by LLM from diff + user intent | debug.log: `llm-start` → `llm-success` (not `llm-timeout-or-empty`, not `llm-invalid-format`) |
| 11 | Deterministic fallback | If LLM fails → first line of user prompt used | debug.log: `reword` with `source: "deterministic"` (acceptable, but track frequency) |
| 12 | Commit reword | `but reword` applied to unpushed commits | debug.log: `reword` entries (not `reword-failed`) |

### Branch Naming

| # | Feature | Expected Behavior | How to Verify |
|---|---------|-------------------|---------------|
| 13 | Branch auto-rename | `ge-branch-N` renamed to meaningful slug from user prompt | debug.log: `branch-rename` entries (not `branch-rename-failed`) |
| 14 | No rename of user-named | Branches not matching `ge-branch-\d+` are left alone | debug.log: absence of rename attempts on non-default branches |

### Agent Awareness

| # | Feature | Expected Behavior | How to Verify |
|---|---------|-------------------|---------------|
| 15 | Context injection | Agent's next message gets `<system-reminder>` with operation summary | debug.log: `notification-queued` → later `context-injected` |
| 16 | Session title sync | OpenCode session title matches branch name | debug.log: look for title update entries after rename |

### Multi-Agent Safety

| # | Feature | Expected Behavior | How to Verify |
|---|---------|-------------------|---------------|
| 17 | Session mapping | Subagent sessions resolve to parent via `resolveSessionRoot()` | debug.log: `session-map-subagent` entries |
| 18 | No cross-session leaks | Each root session gets its own branch, no mixing | Cross-reference `session-map-created` entries with `but status` branches |

### Robustness

| # | Feature | Expected Behavior | How to Verify |
|---|---------|-------------------|---------------|
| 19 | State persistence | Plugin state survives restart (`conversationsWithEdits`, `rewordedBranches`) | debug.log: `state-loaded` on init with non-zero counts |
| 20 | Lock stale cleanup | Stale locks (>60s) are force-released | debug.log: `lock-stale` entries (acceptable), no `lock-timeout` |
| 21 | Rub multi-branch guard | Files with hunks in multiple stacks skip auto-assign | debug.log: `rub-skip-multi-branch` (correct guard behavior) |

---

## Guardrails

### Hard Constraints (non-negotiable)

1. **Read-only**: Do NOT edit any source files. This command observes and reports.
2. **No git mutations**: No `git add`, `commit`, `push`, `reset`, `checkout`. Read-only git commands only.
3. **No patches**: Zero code changes. Findings only.
4. **Consult before acting**: If you identify something that needs fixing, describe it in the report and discuss with the operator. Do not fix it yourself.

---

## Data Sources

The loop draws from 4 sources. Each is **optional** — degrade gracefully when unavailable.

| # | Source | What It Tells You | How to Access | Fallback |
|---|--------|-------------------|---------------|----------|
| 1 | **Plugin debug log** | Full runtime event trail: every hook call, every rub, every reword, every error | `.opencode/plugin/debug.log` (NDJSON, one JSON object per line) | `[WARN] debug.log not found — skipping` |
| 2 | **Session history** | What the user asked, what the agent did, session flow | OpenCode session tools (`session_list`, `session_read`, `session_search`) | `[WARN] No sessions found — skipping` |
| 3 | **Git log** | Recent commits on plugin-managed branches — verify commit messages, branch names | `git log --oneline -50` + `git branch -a` | Always available |
| 4 | **`but` CLI status** | Current workspace state: branches, assigned files, uncommitted changes | `but status --json -f` | `[WARN] but CLI not found — skipping` |

**At least one source must yield data.** If all 4 are empty → ABORT.

### Debug Log Categories Reference

The debug log is your primary data source. Key categories:

| Category | Level | Meaning |
|----------|-------|---------|
| `plugin-init` | info | Plugin started — check config loaded correctly |
| `state-loaded` | info | Persisted state restored — check counts |
| `lock-acquired` / `lock-released` | info | File lock lifecycle — should be paired |
| `lock-stale` | warn | Force-released stale lock — acceptable but note frequency |
| `lock-timeout` | error | **DX problem** — lock held too long, edit was blocked |
| `after-edit` | info | File edit processed — core flow |
| `cursor-ok` | info | `but cursor` call succeeded — check `subcommand` field |
| `cursor-error` | error | **DX problem** — CLI call failed |
| `cursor-after-edit-error` | error | **DX problem** — after-edit specifically failed |
| `rub-ok` | info | Auto-assign to existing branch succeeded |
| `rub-failed` | error | **DX problem** — file didn't land in correct branch |
| `rub-skip-multi-branch` | warn | Correct guard — file in multiple stacks |
| `session-stop` | info | Session went idle — stop flow started |
| `cursor-stop-error` | error | **DX problem** — stop/commit failed |
| `post-stop-start` | info | Post-processing started (reword, rename, cleanup) |
| `llm-start` | info | LLM commit message generation started |
| `llm-success` | info | LLM produced valid commit message |
| `llm-timeout-or-empty` | warn | **DX degradation** — fell back to deterministic |
| `llm-invalid-format` | warn | **DX degradation** — LLM output rejected |
| `reword` | info | Commit message rewritten — check `source` field |
| `reword-failed` | warn | **DX problem** — commit message stuck as generic |
| `reword-error` | error | **DX problem** — reword crashed |
| `branch-rename` | info | Branch renamed from `ge-branch-N` to meaningful name |
| `branch-rename-failed` | warn | **DX problem** — branch stuck as `ge-branch-N` |
| `cleanup-ok` | info | Empty branch removed |
| `cleanup-failed` | error | **DX problem** — empty branch lingers |
| `session-map-created` | info | New session→branch mapping |
| `session-map-subagent` | info | Subagent linked to parent session |
| `notification-queued` | info | Agent notification prepared |
| `context-injected` | info | Agent received notification on next message |

---

## Phases

### Phase 1: Setup

1. **Record start time**
   ```
   Set START_TIME = now()
   Set MAX_DURATION = 20 minutes
   Set iteration = 0
   Set consecutive_zero_finding_count = 0
   ```

2. **Probe data sources**
   ```
   For each of the 4 data sources:
     Check availability
     Log status: [OK] or [WARN] with reason
   If all 4 unavailable → ABORT("No data sources available")
   ```

3. **Initialize scorecard**
   ```
   Create empty scorecard from Feature Parity Baseline (21 features)
   Each feature starts as: { status: "untested", evidence: [], notes: "" }
   ```

4. **Detect project context**
   ```
   Check: Is this the plugin repo itself, or a consumer project?
   - Plugin repo: analyze git log for plugin source changes, run build/test as reference
   - Consumer project: analyze debug.log + but status for runtime behavior
   Both: session history is always relevant
   ```

---

### Phase 2: Analysis Loop

Repeat until stop condition met. Each iteration focuses on a **feature cluster** from the baseline.

#### Iteration Focus Order

| Iteration | Cluster | Features | Primary Source |
|-----------|---------|----------|----------------|
| 1 | **Core Flow** | #1, #2, #3, #4, #9 | debug.log |
| 2 | **Branch & Assignment** | #5, #6, #7, #8 | debug.log + but status |
| 3 | **Commit Quality** | #10, #11, #12 | debug.log + git log |
| 4 | **Branch Naming** | #13, #14 | debug.log + git log + but status |
| 5 | **Agent Awareness** | #15, #16, #17, #18 | debug.log + session history |
| 6 | **Robustness** | #19, #20, #21 | debug.log |
| 7+ | **Cross-cutting** | Re-examine failed/degraded features with additional data | All sources |

If a source needed for a cluster is unavailable, mark those features as `untested (source unavailable)` and move on.

#### Step 2.1: Gather Evidence

For the current cluster's features:

- **Parse debug.log** for relevant categories (use the reference table above)
- **Query but status** for current workspace state
- **Search session history** for user prompts, agent actions, error mentions
- **Check git log** for commit messages, branch names

Count occurrences. Calculate success/failure ratios. Identify patterns.

#### Step 2.2: Score Each Feature

For each feature in the cluster, assign a status:

| Status | Meaning | Criteria |
|--------|---------|----------|
| **Working** | Feature works as expected | >90% success rate in observed events |
| **Degraded** | Feature works sometimes, fails sometimes | 50-90% success rate, or works with fallback |
| **Broken** | Feature consistently fails | <50% success rate |
| **Untested** | No data available to evaluate | Source unavailable or no relevant events |

Include evidence:
```
Feature #10 (LLM commit message):
  Status: Degraded
  Evidence: 12 llm-start, 8 llm-success, 3 llm-timeout-or-empty, 1 llm-invalid-format
  Success rate: 67%
  Note: Timeouts cluster around large diffs (>3000 chars). Consider increasing llm_timeout_ms.
```

#### Step 2.3: Identify DX Issues

From scored features, extract actionable findings:

- **What's broken** — things that don't work and need fixing
- **What's degraded** — things that work unreliably and need investigation
- **What's annoying** — things that work but create friction (e.g., slow lock acquisition)
- **What's missing** — flows that should exist but aren't covered

For each finding, describe:
1. **What the user experiences** (not what the code does)
2. **Root cause hypothesis** (based on log evidence)
3. **Suggested fix direction** (not the code — the approach)

#### Step 2.4: Update Scorecard & Counters

```
Update feature scores in scorecard
If new_findings == 0:
  consecutive_zero_finding_count += 1
Else:
  consecutive_zero_finding_count = 0
iteration += 1
```

#### Step 2.5: Stop Condition Check

| Condition | Action |
|-----------|--------|
| `now() - START_TIME >= 20 minutes` | STOP — timeout |
| `consecutive_zero_finding_count >= 2` | STOP — converged |
| All 21 features scored (no `untested` remaining) | STOP — complete |
| Critical error in analysis | STOP — abort |

---

### Phase 3: Report

Write final report to `.opencode/analysis-loop/report.md`:

```markdown
# Plugin DX Analysis Report

## Metadata
- **Project**: {project name / path}
- **Context**: {plugin repo | consumer project}
- **Date**: {ISO timestamp}
- **Duration**: {minutes}m {seconds}s
- **Data sources**: {list with status}
- **Iterations**: {N}

## Feature Scorecard

| # | Feature | Status | Success Rate | Key Evidence |
|---|---------|--------|--------------|--------------|
| 1 | Post-edit hook | Working | 100% (24/24) | All cursor-ok |
| 2 | Stop/idle hook | Working | 100% (8/8) | All session-stop -> cursor-ok |
| ... | ... | ... | ... | ... |
| 10 | LLM commit message | Degraded | 67% (8/12) | 3 timeouts on large diffs |
| 13 | Branch auto-rename | Broken | 0% (0/8) | All branch-rename-failed |
| ... | ... | ... | ... | ... |

**Summary**: {N} working, {N} degraded, {N} broken, {N} untested

## Findings

### Critical (Broken)

#### Finding 1: {title}
- **User experience**: {what the user sees/doesn't see}
- **Evidence**: {log entries, counts, timestamps}
- **Root cause**: {hypothesis}
- **Suggested direction**: {approach, not code}

### Important (Degraded)

#### Finding 2: {title}
...

### Improvement Opportunities

#### Finding 3: {title}
...

## Raw Data Summary
- debug.log: {total entries} entries, {error count} errors, {warn count} warnings
- but status: {branch count} branches, {unassigned count} unassigned changes
- Session history: {session count} sessions analyzed
- Git log: {commit count} recent commits checked

## Recommendations
{Prioritized list of suggested next steps — for discussion with operator}
```

---

## Stop Conditions (Summary)

| Condition | Threshold | Behavior |
|-----------|-----------|----------|
| **Hard timeout** | 20 minutes | Exit to report |
| **Convergence** | 2 iterations with 0 new findings | Exit to report |
| **Full coverage** | All 21 features scored | Exit to report |
| **All sources unavailable** | 0 of 4 reachable | Abort in setup |
| **Critical error** | Unrecoverable | Abort to report |

---

## What This Command Does NOT Do

- Does NOT edit any files (read-only analysis)
- Does NOT apply patches or fixes
- Does NOT commit, push, or mutate git
- Does NOT run indefinitely (20-min cap)
- Does NOT require all data sources
- Does NOT fix things autonomously — findings are **proposals for discussion**
